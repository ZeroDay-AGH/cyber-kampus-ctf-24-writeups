"""
Majority of code from https://eprint.iacr.org/2019/032.pdf
Safety in Numbers: On the Need for Robust Diffie-Hellman Parameter Validation
"""


# This file was *autogenerated* from the file gen_carmichael.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_810810 = Integer(810810); _sage_const_2088450 = Integer(2088450); _sage_const_4054050 = Integer(4054050); _sage_const_7657650 = Integer(7657650); _sage_const_13783770 = Integer(13783770); _sage_const_22972950 = Integer(22972950); _sage_const_53603550 = Integer(53603550); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_6 = Integer(6)
import itertools
from operator import mul

def all_combinations(any_list): 
    """
    Wrapper for itertools to generate all possible combinations of all (non trivial) sizes.
    """
    return itertools.chain.from_iterable(itertools.combinations(any_list , i + _sage_const_1 ) for i in range(len(any_list)))

def LCMpim1(n):
    """
    Takes as input n: a list of integers p_i and returns the lcm(p_i-1) for all i 
    """
    pim1list = []
    for pi in n:
        pim1 = pi - _sage_const_1 
        pim1list.append(pim1) 
    return lcm(pim1list)

def listbuild(L):
    """
    Takes as input a (highly composite) number L and returns a list of all primes p such 
    that p-1 | L where p does not divide L. We include the additional requirement that p = 3 mod 4.
    """
    a = list(factor(L))
    p = []
    for y in a:
        for i in range(_sage_const_0 , y[_sage_const_1 ]): 
            p.append(y[_sage_const_0 ])
    
    pvals = all_combinations(p) 
    ps = []
    for pp in pvals:
        t = reduce(mul, pp, _sage_const_1 )
        tt = t + _sage_const_1 
        if tt.is_prime(proof=False) and L % tt != _sage_const_0 :
            if tt not in ps: 
                ps.append(tt)
    pps = []
    ps.sort()
    # we now filter results to only inlude p with p = 3 mod 4 
    for p in ps:
        if p % _sage_const_4  == _sage_const_3 : 
            pps.append(p)
    return pps

def erdos_build(factors , L, k):
    """
    This function takes a list of possible factors, a (highly composite) integer L and k,
    and produces a Carmichael number with k factors sampled from "factors" such that the 
    LCM of each factor p_i - 1 is equal to L. Output is parsed as n,[p_1,p_2,...,p_k] 
    where n = p_1 * p_2 * ... * p_k.
    """
    if k <=_sage_const_2 :
        print("Choice of factors must be >=3")
        return _sage_const_0 
    for i in itertools.combinations(factors , k):
        v = reduce(mul, i, _sage_const_1 ) 
        if v % L == _sage_const_1 :
            fin = list(i) 
            fin.sort()
            if LCMpim1(fin) == L:
                return [v,fin]
    print("None found, try increasing size of factor list")


def granville_and_pomerance(factors):
    k = _sage_const_1 
    L = LCMpim1(factors)
    while True:
        M = _sage_const_1  + k*L
        qs = [_sage_const_1  + M*(p-_sage_const_1 ) for p in factors]
        if all(q.is_prime(proof=False) for q in qs):
            N = prod(qs)
            return N, qs
        k += _sage_const_1 


Ls = [_sage_const_810810 , _sage_const_2088450 , _sage_const_4054050 , _sage_const_7657650 , _sage_const_13783770 , _sage_const_22972950 , _sage_const_53603550 ]

# Small L picked to keep N.nbits() small
L = _sage_const_2 *_sage_const_3 **_sage_const_4 *_sage_const_5 *_sage_const_7 *_sage_const_11 **_sage_const_2 
factors = listbuild(L)
print(factors, L, len(factors))

char, car_factors = erdos_build(factors , L, _sage_const_6 )
print(char, car_factors)

N, qs = granville_and_pomerance(car_factors)

print(N)
print(qs)
print('N bits', N.nbits())
print([q.nbits() for q in qs])

